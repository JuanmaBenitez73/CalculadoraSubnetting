@page "/"
@using System.Text.RegularExpressions;
@using Microsoft.JSInterop;
@inject IJSRuntime JSRuntime

<PageTitle>Calculadora Subnetting</PageTitle>
<body @onload="CalculateSubnets">
	@*@onload="CalculateSubnets"*@
	<div id="div1">
		<div id="title">
			<h1>Calculadora de Subnetting (FLSM)</h1>
		</div>
		<br />
		<div id="description">
			<h5>Esta es una calculadora de redes con el uso de subnetting mediante el método FLSM (Máscara de Red Fija)</h5>
		</div>
		<br />
		<br />
		<div id="request">
			Introduce una Dirección IP con una máscara de red, el tamaño de las redes y la cantidad de subredes que deseas
		</div>
	</div>
	<div id="div-table1">
		<table class="my-border">
			<tr>
				<td class="center my-border">Dirección IP y Máscara</td>
				<td colspan="4" class="my-border"><input type="text" @bind="IpAddress" /></td>
			</tr>
			<tr class="center">
				<td rowspan="@RowSpan" class="my-border">Subredes</td>
				<td colspan="2" class="right-border">Nombre</td>
				<td colspan="2">Tamaño</td>
			</tr>
			@for (int i = 0; i < NumberOfSubnets; i++)
			{
				<tr>
					<td colspan="2" class="right-border"><input type="text" placeholder="Subred" /></td>
					<td colspan="2"><input type="number" class="hosts-required" /></td>
				</tr>
			}
			<tr class="top-border">
				<td class="center">Número de subredes:</td>
				<td colspan="2"><input id="n-subnets" type="number" @bind="NumberOfSubnets"/></td>
				<td><button type="submit" @onclick="VerifyNumberOfSubnets">Change</button></td>
			</tr>
			<tr>
				<td colspan="5" class="my-border"><button type="submit">Submit</button></td>@*@onclick="CalculateSubnets"*@
			</tr>
		</table>
	</div>
</body>

@code {
	private IJSInProcessObjectReference module;

	class SubnetInfo
	{
		public string Name { get; set; }
		public int HostsRequired { get; set; }
		public string SubnetAddress { get; set; }
		public string SubnetMask { get; set; }
		public string BroadcastAddress { get; set; }
		public string RangeStart { get; set; }
		public string RangeEnd { get; set; }
		public int AvailableHosts { get; set; }

		public SubnetInfo() { }
	}

	public int RowSpan => NumberOfSubnets + 1;

	private bool showResults = false;
	public string IpAddress { get; set; }
	public int NumberOfSubnets { get; set; }
	List<SubnetInfo> Subnets { get; set; } = new List<SubnetInfo>();

	SubnetInfo subnetInfo = new SubnetInfo();

	public async void CalculateSubnets()
	{
		//VerifyNumberOfSubnets();

		showResults = false;

		Subnets.Clear();

		string ipPattern = @"\b(?:\d{1,3}\.){3}\d{1,3}\b";

		string maskPattern = @"/{1}\d{1,2}";

		string ipAddress = IpAddress;

		int subnetMask = 0;

		Match ipMatch = Regex.Match(ipAddress, ipPattern);

		Match maskMatch = Regex.Match(ipAddress, maskPattern);

		string ip = ipAddress.Split('/')[0];
		List<string> octetos = new List<string>();
		List<int> octetosIp = new List<int>();

		if (ipMatch.Success && maskMatch.Success)
		{
			subnetMask = int.Parse(ipAddress.Split('/')[1]);

			foreach (var item in ip.Split('.'))
			{
				octetos.Add(item);
			}
			foreach (var item in octetos)
			{
				if (int.Parse(item) >= 0 && int.Parse(item) <= 255)
				{
					octetosIp.Add(int.Parse(item));
				}
				else
				{
					await module.InvokeVoidAsync("incorrectRange");
				}
			}
		}
		else
		{
			IpAddress = "";
		}

		List<byte> ipBytes = new List<byte>();
		byte ipmaskBytes = (byte)(subnetMask);
		List<byte> ipsmaskBytes = new List<byte> { (byte)(subnetMask >> 24), (byte)(subnetMask >> 16), (byte)(subnetMask >> 8), (byte)subnetMask };

		foreach (int item in octetosIp)
		{
			ipBytes.Add((byte)(item));
		}

		//El tamaño de cada subred
		int subnetSize = (int)Math.Pow(2, 32 - subnetMask) / NumberOfSubnets;

		int maxNumberOfHosts = (int)Math.Pow(2, 32 - ipmaskBytes) - 2;
		if (subnetInfo.HostsRequired > maxNumberOfHosts)
		{
			
			Console.WriteLine("El número de hosts especificado no es válido para la máscara de subred dada.");
			return;
		}

		for (int i = 0; i < NumberOfSubnets; i++)
		{
			Subnets[i].HostsRequired = subnetInfo.HostsRequired;

			subnetInfo.SubnetAddress = GetSubnetAddress(ipBytes, ipsmaskBytes, subnetSize, i);

			subnetInfo.SubnetMask = GetSubnetMask(ipmaskBytes);

			subnetInfo.BroadcastAddress = GetBroadcastAddress(subnetInfo.SubnetAddress, subnetInfo.SubnetMask);

			subnetInfo.AvailableHosts = GetAvailableHosts(subnetInfo.RangeStart, subnetInfo.RangeEnd);

			Subnets.Add(subnetInfo);

		}
	}

	public void VerifyNumberOfSubnets()
	{
		if (NumberOfSubnets <= 0)
		{
			NumberOfSubnets = 1;
		}
		else
		{
			//for (int i = 0; i < NumberOfSubnets; i++)
			//{
			//	Subnets[i].HostsRequired = subnetInfo.HostsRequired;


			//}
		}
	}

	protected override async Task OnInitializedAsync()
	{
		await base.OnInitializedAsync();

		module = await JSRuntime.InvokeAsync<IJSInProcessObjectReference>("import", "./js/main.js");
	}

	private string GetSubnetAddress(List<byte> ipBytes, List<byte> maskBytes, int subnetSize, int subnetIndex)
	{
		List<byte> subnetAddressBytes = new List<byte>();
		for (int i = 0; i < 4; i++)
		{
			byte subnetByte = (byte)(ipBytes[i] & maskBytes[i]);
			subnetByte |= (byte)(subnetIndex >> (8 * (3 - i)) & Convert.ToByte("11111111", 2));
			subnetAddressBytes.Add(subnetByte);
		}
		return string.Join(".", subnetAddressBytes);
	}

	private string GetSubnetMask(int maskBits)
	{
		int fullBytes = maskBits / 8;
		int remainderBits = maskBits % 8;
		List<byte> maskBytes = new List<byte>();

		for (int i = 0; i < fullBytes; i++)
		{
			maskBytes.Add(255);
		}
		if (remainderBits > 0)
		{
			//Esto lo que hace es  una mascara de bits para los bits restantes se utiliza lo de las boquillas  para pasar 8 - remainderBits bits hacia la izquierda <3 juanma guapo vaporeoon.
			int remainderMask = 255 << (8 - remainderBits);
			maskBytes.Add((byte)remainderMask);
		}
		while (maskBytes.Count < 4)
		{
			maskBytes.Add(0);
		}

		return string.Join(".", maskBytes);

	}

	private string GetBroadcastAddress(string subnetAddress, string subnetMask)
	{
		List<byte> subnetAddressBytes = subnetAddress.Split('.').Select(byte.Parse).ToList();
		List<byte> subnetMaskBytes = subnetMask.Split('.').Select(byte.Parse).ToList();
		List<byte> broadcastAddressBytes = new List<byte>();

		for (int i = 0; i < 4; i++)
		{
			byte broadcastByte = (byte)(subnetAddressBytes[i] | ~subnetMaskBytes[i]);
			broadcastAddressBytes.Add(broadcastByte);
		}

		return string.Join(".", broadcastAddressBytes);

	}

	private string GetFirstHostAddress(string subnetAddress)
	{
		List<byte> subnetAddressBytes = subnetAddress.Split('.').Select(byte.Parse).ToList();
		subnetAddressBytes[3] += 1;
		return string.Join(".", subnetAddressBytes);

	}

	private string GetLastHostAddress(string broadcastAddress)
	{
		List<byte> broadcastAddressBytes = broadcastAddress.Split('.').Select(byte.Parse).ToList();
		broadcastAddressBytes[3] -= 1;
		return string.Join(".", broadcastAddressBytes);
	}

	private int GetAvailableHosts(string rangeStart, string rangeEnd)
	{
		List<byte> rangeStartBytes = rangeStart.Split('.').Select(byte.Parse).ToList();
		List<byte> rangeEndBytes = rangeEnd.Split('.').Select(byte.Parse).ToList();

		int availableHosts = 0;

		for (int i = 0; i < 4; i++)
		{
			availableHosts += rangeEndBytes[i] - rangeStartBytes[i] + 1;
		}

		return availableHosts;

	}
}