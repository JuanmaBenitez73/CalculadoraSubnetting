@page "/"
@using System.Text.RegularExpressions;
@using Microsoft.JSInterop;
@inject IJSRuntime JSRuntime

<PageTitle>Calculadora Subnetting</PageTitle>
<body>
	@*@onload="CalculateSubnets"*@
	<div id="div1">
		<div id="title">
			<h1>Calculadora de Subnetting (FLSM)</h1>
		</div>
		<br />
		<div id="description">
			<h5>Esta es una calculadora de redes con el uso de subnetting mediante el método FLSM (Máscara de Red Fija)</h5>
		</div>
		<br />
		<br />
		<div id="request">
			Introduce una Dirección IP con una máscara de red, el tamaño de las redes y la cantidad de subredes que deseas
		</div>
	</div>
	<div id="div-table1">
		<table class="my-border">
			<tr>
				<td class="center my-border">Dirección IP y Máscara</td>
				<td colspan="4" class="my-border"><input type="text" @bind="IpAddress" /></td>
			</tr>
			<tr class="center">
				<td rowspan="@RowSpan" class="my-border">Subredes</td>
				<td colspan="2" class="right-border">Nombre</td>
				<td colspan="2">Tamaño</td>
			</tr>
			@for (int i = 0; i < NumberOfSubnets; i++)
			{
				<tr>
					<td colspan="2" class="right-border"><input type="text" placeholder="Subred" /></td>
					<td colspan="2"><input type="number" id="hosts-required" /></td>
				</tr>
			}
			<tr class="top-border">
				<td class="center">Número de subredes:</td>
				<td colspan="2"><input id="n-subnets" type="number" @bind="NumberOfSubnets" /></td>
				<td><button type="submit">Change</button></td>
			</tr>
			<tr>
				<td colspan="5" class="my-border"><input type="submit" @onclick="CalculateSubnets" value="Submit"></input></td>
			</tr>
		</table>
	</div>
</body>

@code {
	class SubnetInfo
	{
		public string Name { get; set; }
		public int HostsRequired { get; set; }
		public string SubnetAddress { get; set; }
		public string SubnetMask { get; set; }
		public string BroadcastAddress { get; set; }
		public string RangeStart { get; set; }
		public string RangeEnd { get; set; }
		public int AvailableHosts { get; set; }

		public SubnetInfo() { }
	}

	public int RowSpan => NumberOfSubnets + 1;

	private bool showResults = false;
	public string IpAddress { get; set; }
	public int NumberOfSubnets { get; set; }
	List<SubnetInfo> Subnets { get; set; } = new List<SubnetInfo>();

	SubnetInfo subnetInfo = new SubnetInfo();

	public async void CalculateSubnets()
	{
		VerifyNumberOfSubnets();

		showResults = false;

		Subnets.Clear();

		string ipPattern = @"\b(?:\d{1,3}\.){3}\d{1,3}\b";

		string maskPattern = @"/{1}\d{1,2}";

		string ipAddress = IpAddress;

		int subnetMask = 0;

		Match ipMatch = Regex.Match(ipAddress, ipPattern);

		Match maskMatch = Regex.Match(ipAddress, maskPattern);

		string ip = ipAddress.Split('/')[0];
		List<string> octetos = new List<string>();
		List<int> octetosIp = new List<int>();

		if (ipMatch.Success && maskMatch.Success)
		{
			subnetMask = int.Parse(ipAddress.Split('/')[1]);

			foreach (var item in ip.Split('.'))
			{
				octetos.Add(item);
			}
			foreach (var item in octetos)
			{
				if (int.Parse(item) >= 0 && int.Parse(item) <= 255)
				{
					octetosIp.Add(int.Parse(item));
				}
				else
				{
					await JSRuntime.InvokeVoidAsync("incorrectRange");
					//Console.WriteLine("Alguno de los números está fuera del rango disponible");
				}
			}
		}
		else
		{
			IpAddress = "";
		}

		List<byte> ipBytes = new List<byte>();
		byte ipmaskBytes = (byte)(subnetMask);

		foreach (int item in octetosIp)
		{
			ipBytes.Add((byte)(item));
		}

		//El tamaño de cada subred
		int subnetSize = (int)Math.Pow(2, 32 - subnetMask) / NumberOfSubnets;

		for (int i = 0; i < NumberOfSubnets; i++)
		{
			Subnets[i].HostsRequired = subnetInfo.HostsRequired;



		}
	}

	public void VerifyNumberOfSubnets()
	{
		if (NumberOfSubnets <= 0)
		{
			NumberOfSubnets = 1;
		}
		else
		{
			//for (int i = 0; i < NumberOfSubnets; i++)
			//{
			//	Subnets[i].HostsRequired = subnetInfo.HostsRequired;


			//}
		}
	}

	private string GetSubnetAddress(List<byte> ipBytes, List<byte> maskBytes, int subnetSize, int subnetIndex)
	{
		List<byte> subnetAddressBytes = new List<byte>();
		for (int j = 0; j < 4; j++)
		{
			byte subnetByte = (byte)(ipBytes[j] & maskBytes[j]);
			subnetByte |= (byte)(subnetIndex >> (8 * (3 - j)) & 0xFF);
			subnetAddressBytes.Add(subnetByte);
		}
		return string.Join(".", subnetAddressBytes);
	}

	public void GetSubnetMask()
	{


	}

	public void GetBroadcastAddress()
	{

	}

	public void GetFirstHostAddress()
	{

	}

	public void GetLastHostAddress()
	{

	}

	public void GetAvailableHosts()
	{

	}
}